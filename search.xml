<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程</title>
      <link href="/2024/06/24/ruan-jian-gong-cheng/"/>
      <url>/2024/06/24/ruan-jian-gong-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程（28-A7218-13-00）"><a href="#软件工程（28-A7218-13-00）" class="headerlink" title="软件工程（28-A7218-13:00）"></a>软件工程（28-A7218-13:00）</h1><h2 id="第一章、软件工程概述"><a href="#第一章、软件工程概述" class="headerlink" title="第一章、软件工程概述"></a>第一章、软件工程概述</h2><h4 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h4><p>软件工程是采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理方法和最先进的软件开发技术结合起来，应用到软件开发和维护的过程中，来解决软件危机问题。</p><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><p>软件危机（计算机软件的开发和维护中遇到的严重问题）的表现形式：</p><ol><li><p>软件成本高</p></li><li><p>开发进度难以控制</p></li><li><p>工作量估计困难</p></li><li><p>软件产品的质量差</p></li><li><p>软件进行修改、维护困难</p></li></ol><h4 id="软件工程三要素："><a href="#软件工程三要素：" class="headerlink" title="软件工程三要素："></a>软件工程三要素：</h4><p>工具、方法、过程。</p><h4 id="软件生命周期："><a href="#软件生命周期：" class="headerlink" title="软件生命周期："></a>软件生命周期：</h4><ol><li><p>软件定义<br>1.问题定义<br>2.可行性分析<br>3.需求分析</p></li><li><p>软件开发<br>1.软件设计<br>2.程序编码<br>3.软件测试</p></li><li><p>运行与维护</p></li></ol><h4 id="常用的开发过程模型"><a href="#常用的开发过程模型" class="headerlink" title="常用的开发过程模型"></a>常用的开发过程模型</h4><ol><li><p>瀑布模型（自顶向下结构化）阶段：问题定义、需求分析、软件设计、编码、测试、运行和维护。</p><ul><li><p>优点：1.支持开发结构化软件、控制并降低软件开发的复杂度、促进软件开发工程化。；2.为软件开发和维护提供较为有效的管理模式。</p></li><li><p>缺点：1.实际项目很少按模型给出的顺序进行。；2.不能接受在项目开始阶段的不确定性。；3.客户需要有耐心。；4.流程单一，不能适应需求变化，风险往往出现在后期。</p></li></ul></li><li><p>原型（演化）模型（把主要功能接口做为设计依据）</p></li><li><p>螺旋模型（沿着螺线旋转（一个螺旋式周期）），适用于风险较大的复杂项目</p></li><li><p>统一过程模型RUP（一个通用的过程框架），使用统一建模语言来制定软件系统的所有蓝图。</p><ul><li><p>特点：1.软件开发是一个迭代的过程。<br>           2.软件开发是由用例驱动的。<br>           3.软件开发是以架构设计为中心 。</p></li><li><p>阶段：初始、细化、构造、交付。</p></li><li><p>核心工作流程：1.业务建模。；2.需求。；3.分析与设计。；4.实现。；5.测试。；6.部署。；7.配置与变更管理。；8.项目管理。；9.环境。</p></li></ul></li></ol><h2 id="第二章、软件项目管理"><a href="#第二章、软件项目管理" class="headerlink" title="第二章、软件项目管理"></a>第二章、软件项目管理</h2><h4 id="项目的三维管理"><a href="#项目的三维管理" class="headerlink" title="项目的三维管理"></a>项目的三维管理</h4><ol><li><p>时间维</p></li><li><p>知识维</p></li><li><p>保障维</p></li></ol><h4 id="项目的五个阶段"><a href="#项目的五个阶段" class="headerlink" title="项目的五个阶段"></a>项目的五个阶段</h4><ol><li><p>启动阶段：用户提出需求，开发人员进行需求分析，确定可行性，编写项目实施计划。</p></li><li><p>计划阶段：创建项目范围文档和项目计划，项目范围详细描述项目范围。</p></li><li><p>执行阶段：实施阶段意味着项目正在进一步设计、编码、测试，小组成员正在创造项目需要的可交付产品。</p></li><li><p>控制阶段：项目经理开始监督小组成员的工作，将项目的进度、任务和预算控制在正常的范围内。</p></li><li><p>收尾阶段：项目负责人和用户批准和签署项目，交付产品。项目的收尾阶段标志着项目的正式结束。</p></li></ol><p>软件项目管理涵盖了管理软件产品开发所需的知识、技术及工具。</p><h4 id="软件项目管理的目的"><a href="#软件项目管理的目的" class="headerlink" title="软件项目管理的目的"></a>软件项目管理的目的</h4><p>软件项目管理的目的是为了按照预定的进度、费用等要求，成功地组织与实施软件的工程化生产，完成软件（产品）的开发和维护任务。</p><h4 id="范围包括四个方面"><a href="#范围包括四个方面" class="headerlink" title="范围包括四个方面"></a>范围包括四个方面</h4><ul><li><p>组织管理</p></li><li><p>成本管理</p></li><li><p>进度管理</p></li><li><p>质量管理</p></li></ul><h4 id="项目范围的管理包括"><a href="#项目范围的管理包括" class="headerlink" title="项目范围的管理包括"></a>项目范围的管理包括</h4><p>范围计划编制、范围定义、范围确认、范围控制。</p><p>风险的分类：项目风险、外来风险。</p><h2 id="第三章、需求概述"><a href="#第三章、需求概述" class="headerlink" title="第三章、需求概述"></a>第三章、需求概述</h2><h4 id="需求的定义"><a href="#需求的定义" class="headerlink" title="需求的定义"></a>需求的定义</h4><p>用户解决问题或达到目标所需要的条件和权能；系统或系统部件要满足合同、标准、规范或其他正式规定文档所要具有的条件或权能。</p><h4 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h4><h5 id="（按性质）："><a href="#（按性质）：" class="headerlink" title="（按性质）："></a>（按性质）：</h5><ol><li><p>功能性需求（系统应该提供的服务、对输入如何响应及特定条件下系统行为的描述）</p></li><li><p>非功能性需求</p></li></ol><h5 id="（按层次）："><a href="#（按层次）：" class="headerlink" title="（按层次）："></a>（按层次）：</h5><ol><li><p>领域需求</p></li><li><p>业务需求</p></li><li><p>用户需求</p></li><li><p>系统需求</p></li></ol><h4 id="软件需求工程阶段的工作划分"><a href="#软件需求工程阶段的工作划分" class="headerlink" title="软件需求工程阶段的工作划分"></a>软件需求工程阶段的工作划分</h4><ol><li><p>对问题的识别</p></li><li><p>分析与综合</p></li><li><p>制定需求规格说明</p></li><li><p>需求分析评审</p></li></ol><h4 id="获取需求的方法"><a href="#获取需求的方法" class="headerlink" title="获取需求的方法"></a>获取需求的方法</h4><ol><li><p>建立联合分析小组</p></li><li><p>客户访谈</p></li><li><p>问卷调查</p></li><li><p>快速原型法</p></li></ol><h4 id="功能建模的方法"><a href="#功能建模的方法" class="headerlink" title="功能建模的方法"></a>功能建模的方法</h4><ol><li><p>数据流图法</p></li><li><p>功能列表法</p></li><li><p>原型法</p></li><li><p>用例模型（面向对象功能建模，可包括用例图和用例规约）</p></li><li><p>用户故事（适用于敏捷开发）</p></li></ol><h2 id="第四章、需求建模"><a href="#第四章、需求建模" class="headerlink" title="第四章、需求建模"></a>第四章、需求建模</h2><h4 id="用例是什么"><a href="#用例是什么" class="headerlink" title="用例是什么"></a>用例是什么</h4><ul><li><p>用例描述了在不同条件下，系统对某一项目相关人员的请求所作出的响应，是系统中各相关人员之间就系统行为所达成的契约。</p></li><li><p>根据参与者作出的请求和请求涉及的条件，系统将执行不同的行为序列，每一行为序列被称之为一个场景。</p></li><li><p>一个用例是多个不同场景的集合。</p></li></ul><h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><img title="" src="https://qinmievc.github.io/img/用例图.png" class="lazyload placeholder" data-srcset="https://qinmievc.github.io/img/用例图.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="用例图" style="zoom:50%;"><h4 id="用例的重要特性"><a href="#用例的重要特性" class="headerlink" title="用例的重要特性"></a>用例的重要特性</h4><ol><li><p>一个用例是一个自包含的单元。</p></li><li><p>一个用例必须由参与者发起。</p></li><li><p>用例必须完成一个特定目标。</p></li><li><p>一个用例必须终于参与者，使系统保持在稳定状态。</p></li></ol><h4 id="构建用例模型的过程"><a href="#构建用例模型的过程" class="headerlink" title="构建用例模型的过程"></a>构建用例模型的过程</h4><ol><li><p>获取事件清单</p></li><li><p>将事件清单整理到事件表中</p></li><li><p>采用用例图描述分析的结果</p></li><li><p>对用例进行描述</p></li></ol><h4 id="用例描述的组成部分"><a href="#用例描述的组成部分" class="headerlink" title="用例描述的组成部分"></a>用例描述的组成部分</h4><ul><li><p>用例标识</p></li><li><p>用例名称</p></li><li><p>涉及的参与者</p></li><li><p>用例概述</p></li><li><p>前置条件（Preconditions）</p></li><li><p>后置条件（Postconditions）</p></li><li><p>事件流（Flowof Events）</p></li></ul><p>        •基本流程，不考虑异常；</p><p>        •分支流程（Subflows）</p><h4 id="用例之间的关系"><a href="#用例之间的关系" class="headerlink" title="用例之间的关系"></a>用例之间的关系</h4><ul><li>包含：</li></ul><p><img src="https://qinmievc.github.io/img/%E5%8C%85%E5%90%AB.png" class="lazyload placeholder" data-srcset="https://qinmievc.github.io/img/%E5%8C%85%E5%90%AB.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>扩展</li></ul><p><img src="https://qinmievc.github.io/img/%E6%89%A9%E5%B1%95.png" class="lazyload placeholder" data-srcset="https://qinmievc.github.io/img/%E6%89%A9%E5%B1%95.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>用户故事就是以用户的语言对产品功能（feature）所作的描述。</p><p>用户故事的组成：用户（user）、任务（task）、用户执行任务达到的目标（goal）</p><p>活动图包括：活动、流程、起始点、终节点、判断、泳道。</p><h2 id="第五章、系统分析"><a href="#第五章、系统分析" class="headerlink" title="第五章、系统分析"></a>第五章、系统分析</h2><h4 id="系统分析的目的"><a href="#系统分析的目的" class="headerlink" title="系统分析的目的"></a>系统分析的目的</h4><ol><li><p>初步以面向对象视角理解业务</p></li><li><p>对系统内部组成进行初步抽取</p></li><li><p>获取系统的初步设计</p></li></ol><h4 id="系统分析的技术"><a href="#系统分析的技术" class="headerlink" title="系统分析的技术"></a>系统分析的技术</h4><ol><li><p>领域模型</p></li><li><p>健壮性分析(通过健壮性分析了解都有哪些对象参与了交互)</p></li><li><p>顺序图(通过构建顺序图描述用例场景中对象之间的交互，从而获得分析类图。)</p></li></ol><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p><img src="https://qinmievc.github.io/img/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B.png" class="lazyload placeholder" data-srcset="https://qinmievc.github.io/img/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h2 id="第六章、系统设计"><a href="#第六章、系统设计" class="headerlink" title="第六章、系统设计"></a>第六章、系统设计</h2><h4 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h4><p>运用设计的基本原则模块化将复杂问题进行分解。</p><p>软件体系结构（SoftwareArchitecture）包括构成系统的设计元素的描述、设计元素之间的交互、设计元素的组合模式以及在这些模式中的约束。</p><p>构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素和数据存储。</p><p>连接是构件间建立和维护行为关联与信息传递的途径。</p><p>连接件表示构件之间的交互并实现构件之间的连接。</p><h4 id="常见的体系结构风格"><a href="#常见的体系结构风格" class="headerlink" title="常见的体系结构风格"></a>常见的体系结构风格</h4><ol><li><p>主程序-子程序体系结构（典型）<br>优点：</p><ul><li>有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务。</li></ul><p>缺点：</p><ul><li><p>规模：程序太大，开发太慢，测试越来越困难。</p></li><li><p>可重用性差、数据安全性差。</p></li></ul></li><li><p>MVC模式（模型-视图-控制器）<br>不足：</p><ul><li><p>每次请求必须经过“控制器-&gt;模型-&gt;视图”这个流程，用户才能看到最终的展现的界面。</p></li><li><p>视图是依赖于模型的。</p></li><li><p>渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。</p></li></ul></li><li><p>客户机&#x2F;服务器体系结构（Client&#x2F;Server）</p></li><li><p>分层体系结构</p><ul><li><p>也称为按服务进行划分。</p></li><li><p>是另一种实现分离和独立性的方式。</p></li><li><p>系统按照层次结构组织，每一层向它的上一层提供服务，同时又是它的下层的客户。</p></li><li><p>系统内的交互限定在邻接层之间。</p></li><li><p>除了邻接层，一个内部层次对于其他外部层次是隐藏的。</p></li><li><p>邻接层的关系并不严格。</p></li></ul></li></ol><h4 id="好的软件体系结构带来的作用"><a href="#好的软件体系结构带来的作用" class="headerlink" title="好的软件体系结构带来的作用"></a>好的软件体系结构带来的作用</h4><ol><li><p>提高可重用性</p></li><li><p>提高可扩展性</p></li><li><p>结构简洁</p></li></ol><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库就是对数据的管理。</p><p>业务中包括了对数据的增，删，改，查等操作。</p><p>数据管理中包括用户访问权限，持久化，分布式等不同的方案选择。</p><h5 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h5><ol><li><p>需求阶段的数据搜集</p></li><li><p>概念结构的设计</p></li><li><p>逻辑结构的设计</p></li><li><p>物理结构设计</p></li><li><p>系统实施</p></li><li><p>运行维护</p></li></ol><h4 id="界面设计通用规则"><a href="#界面设计通用规则" class="headerlink" title="界面设计通用规则"></a>界面设计通用规则</h4><ol><li><p>尽量保持一致性</p></li><li><p>为熟练用户提供快捷键</p></li><li><p>提供有效反馈</p></li><li><p>设计完整的对话过程</p></li><li><p>提供简单的错误处理机制</p></li><li><p>允许撤销动作</p></li><li><p>提供控制的内部轨迹</p></li><li><p>减少短期记忆负担</p></li></ol><h4 id="软件设计的通用原则"><a href="#软件设计的通用原则" class="headerlink" title="软件设计的通用原则"></a>软件设计的通用原则</h4><ol><li><p>为改变而设计（产生一个能适应或可以很容易被改变的系统。）</p></li><li><p><strong>关注点分离</strong>（模块独立性）</p></li><li><p><strong>信息隐藏</strong>（隐藏一个模块的实现细节来降低对软件系统其他部分的影响。）</p></li><li><p><strong>高内聚</strong>（内聚性模块或子系统内部的依赖程度）</p></li><li><p><strong>低耦合</strong>（耦合是两个模块或子系统之间依赖关系的强度）</p></li><li><p><strong>隔离可变性</strong>（改变不影响系统其他部分）</p></li><li><p>保持简单和直接</p></li></ol><h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><ul><li><p>偶然内聚（设计者随意决定将无关系的几个功能组合在一个模块中）</p></li><li><p>逻辑内聚（把逻辑上相似的功能结合到一个模块中）</p></li><li><p>时间内聚（在某一时间同时执行的任务放在同一模块中）</p></li><li><p>过程内聚（遵循的步骤顺序有关的操作）</p></li><li><p>通信内聚（所有操作都在相同的数据上进行）</p></li><li><p>顺序内聚（所有的动作都作用在相同的数据结构上，而且一个成分的输出作为另一个成分的输入，这些处理必须依序执行）</p></li><li><p>功能内聚（各部分是为了完成一个确定的功能存在于一个模块中的）</p></li></ul><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><ul><li><p>内容耦合（一个模块访问另一个模块边界中的数据或控制，这种耦合是内容耦合也是最强的耦合）</p></li><li><p>公共耦合（访问同一个公共数据环境（全局数据结构、共享的通信区、内存的公共覆盖区等）</p></li><li><p>外部耦合（一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息）</p></li><li><p>控制耦合（模块与模块之间传递的参数是控制决策作用的。中级别的耦合度。）</p></li><li><p>标记耦合（当模块与模块之间传递的参数是数据结构的一部分时。是数据耦合的变体）</p></li><li><p>数据耦合（模块与模块之间需要通过常规的参数表访问，数据通过该列表传递，传递的数据是简单类型的）</p></li><li><p>非直接耦合（两个模块式不同模块的从属模块，相互之间无关因而没有直接耦合发生）</p></li></ul><h4 id="降低模块间耦合度的原则"><a href="#降低模块间耦合度的原则" class="headerlink" title="降低模块间耦合度的原则"></a>降低模块间耦合度的原则</h4><ul><li><p>尽量使用数据耦合</p></li><li><p>少用控制耦合</p></li><li><p>限制公共耦合的范围</p></li><li><p>坚决避免使用内容耦合</p></li></ul><h4 id="设计总原则（高内聚低耦合）"><a href="#设计总原则（高内聚低耦合）" class="headerlink" title="设计总原则（高内聚低耦合）"></a>设计总原则（高内聚低耦合）</h4><ul><li><p>使每个模块执行一个功能</p></li><li><p>模块间传递数据型参数</p></li><li><p>模块间共用信息尽量少</p></li></ul><h2 id="第七章、对象设计"><a href="#第七章、对象设计" class="headerlink" title="第七章、对象设计"></a>第七章、对象设计</h2><h4 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h4><ol><li><p>单一职责原则（SRP，类的职责要单一）</p></li><li><p>开闭原则（OCP，对可变性封装）</p></li><li><p>依赖倒转原则（DIP，针对接口编程。）</p></li><li><p>里氏替换原则（LSP如何进行继承）</p></li><li><p>接口隔离原则（ISP，恰当的划分角色和接口）</p></li><li><p>合成复用原则（CARP，尽量使用合成&#x2F;聚合、不使用继承）</p></li><li><p>最少知识原则（LoD，不要跟陌生人说话）</p></li></ol><h2 id="第八章、软件实现"><a href="#第八章、软件实现" class="headerlink" title="第八章、软件实现"></a>第八章、软件实现</h2><h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><img title="" src="https://qinmievc.github.io/img/8.jpg" class="lazyload placeholder" data-srcset="https://qinmievc.github.io/img/8.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" style="zoom:50%;"><h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><p>命名、注释、格式。</p><h2 id="第九章、软件测试"><a href="#第九章、软件测试" class="headerlink" title="第九章、软件测试"></a>第九章、软件测试</h2><h4 id="软件测试的目的和原则"><a href="#软件测试的目的和原则" class="headerlink" title="软件测试的目的和原则"></a>软件测试的目的和原则</h4><p>测试的目的是设计测试用例，以最小的代价、在最短时间内系统地发现各种不同类型的错误。</p><h4 id="黑盒测试（功能测试）"><a href="#黑盒测试（功能测试）" class="headerlink" title="黑盒测试（功能测试）"></a>黑盒测试（功能测试）</h4><p>黑盒测试（功能测试）通过测试来检验每个功能是否都能正常使用。</p><p>等价类划分是把程序的输入域划分成若干部分，然后从每个部分中选取少数代表性数据作为参数用例。</p><p>边界值分析其重点在于验证输入或参数的边界条件是否能够正常工作。这种测试方法特别关注于测试输入值的最小值、最大值以及临界值。</p><h4 id="白盒测试（结构测试）"><a href="#白盒测试（结构测试）" class="headerlink" title="白盒测试（结构测试）"></a>白盒测试（结构测试）</h4><p>百盒测试是证明每种内部操作和过程是否符合设计规格和要求。</p><h4 id="黑盒测试与白盒测试的区别"><a href="#黑盒测试与白盒测试的区别" class="headerlink" title="黑盒测试与白盒测试的区别"></a>黑盒测试与白盒测试的区别</h4><p>黑盒测试更关注软件功能是否符合规格说明，而白盒测试更关注软件内部逻辑的完备性和正确性。</p><h2 id="第十章、软件维护"><a href="#第十章、软件维护" class="headerlink" title="第十章、软件维护"></a>第十章、软件维护</h2><h4 id="软件部署作用"><a href="#软件部署作用" class="headerlink" title="软件部署作用"></a>软件部署作用</h4><ul><li><p>保障软件系统的正常运行和功能实现。</p></li><li><p>简化部署的操作过程，提高执行效率。</p></li><li><p>同时还必须满足软件用户在功能和非功能属性方面的个性化需求。</p></li></ul><h4 id="软件维护的意义"><a href="#软件维护的意义" class="headerlink" title="软件维护的意义"></a>软件维护的意义</h4><ul><li><p>提高客户对软件产品的满意度。</p></li><li><p>保持现有系统的价值。</p></li></ul><h4 id="软件维护的分类"><a href="#软件维护的分类" class="headerlink" title="软件维护的分类"></a>软件维护的分类</h4><ul><li><p>改正性维护</p></li><li><p>适应性维护</p></li><li><p>完善性维护</p></li><li><p>预防性维护</p></li></ul><h4 id="软件维护过程"><a href="#软件维护过程" class="headerlink" title="软件维护过程"></a>软件维护过程</h4><p>软件维护准备、接受并响应维护要求、执行软件维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cpp</title>
      <link href="/2024/06/24/cpp/"/>
      <url>/2024/06/24/cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp（26-A4303-13-00）"><a href="#Cpp（26-A4303-13-00）" class="headerlink" title="Cpp（26-A4303-13:00）"></a>Cpp（26-A4303-13:00）</h1><h2 id="第一章、初始C"><a href="#第一章、初始C" class="headerlink" title="第一章、初始C++"></a>第一章、初始C++</h2><p>namespace：可以自定义命名空间</p><p><strong>匿名命名空间</strong>的作用是限制命名空间的内容仅能被当前源文件使用。</p><ul><li><p>cin&gt;&gt;：输入，插入运算符</p></li><li><p>count&lt;&lt;：输出，提取运算符</p></li><li><p>endl;：换行</p></li><li><p>const：常变量</p></li><li><p>bool：逻辑类型，0或1</p></li><li><p>enum：枚举类型</p></li><li><p>new: 在堆上分配内存，并调用对象的构造函数来初始化对象。</p></li><li><p>delete: 释放由 new分配的内存，并调用对象的析构函数来销毁对象。</p></li><li><p><code>*</code> 符号主要用于指针的声明和解引用。</p></li><li><p><code>&amp;</code> 符号主要用于取地址和引用。</p></li></ul><p>函数重载(overload)是指同一作用域内函数名相同但参数个数或者参数类型不同的函数。</p><p>C++的三大特点：</p><ol><li><p>同时支持四种编程范式，面向过程、面向对象、泛型编程、函数式编程。</p></li><li><p>同C语言相比，适合开发大型应用程序。</p></li><li><p>具有可复用、可维护、可扩展、灵活性好的特点。</p></li></ol><p>C++的泛型编程是通过<strong>模版</strong>实现的，该技术可以实现<strong>类型</strong>参数化。</p><p>“开闭原则”，是指对<strong>修改</strong>关闭，对<strong>增加；扩展</strong>开放。</p><p>在C++中，如有类型<strong>参数</strong>，则需要使用  尖括号&lt;&gt; 把类型参数括起来。</p><p>在编程语言的语法描述中（注意，不是说写代码的时候），如果某一部分是可选的，则应使用 <strong>方括号[]</strong> 括起来。</p><h2 id="第二章、类与对象"><a href="#第二章、类与对象" class="headerlink" title="第二章、类与对象"></a>第二章、类与对象</h2><p>构造函数：</p><ul><li><p>对对象进行初始化，其中复制或拷贝构造函数就是用对象初始化新的对象。</p></li><li><p>若没有定义系统会提供一个默认的<strong>无参</strong>构造函数，默认的无参构造函数体也为空，不具有实际初始化意义。</p></li><li><p>自动隐式调用。</p></li><li><p>成员权限控制符一般设置为public。</p></li><li><p>当程序员没有显式的给出拷贝构造函数时，编译器提供默认拷贝构造函数。</p></li><li><p>默认拷贝构造函数是的运行方式是<strong>按位复制</strong>。</p></li><li><p>默认拷贝构造函数容易产生<strong>指针悬挂</strong>问题。</p></li></ul><p>拷贝构造函数：具有构造函数特性，且使用本类对象的引用作为形参，能够通过已存在的对象初始化该类的另一个对象。</p><p>析构函数的功能是释放资源。</p><table><thead><tr><th>构造函数</th><th>析构函数</th></tr></thead><tbody><tr><td>与类同名</td><td>与类同名，前面加~</td></tr><tr><td>没有返回类型，void、return都不要</td><td>没有返回类型，void、return都不要</td></tr><tr><td>可以有参数，可以重载</td><td>没有参数，不能重载</td></tr><tr><td>通常为公有函数</td><td>基类的析构函数通常为虚析构函数</td></tr><tr><td>一个类可以有多个</td><td>一个类只有一个</td></tr></tbody></table><p>友元常见的两种形式是友元函数和友元类。</p><p>友元函数（不是成员函数、破坏隐藏性,尽量少用、在类内声明,使用关键字friend、可以访问类中私有成员）</p><p>类：</p><ul><li><p>类中定义的成员属性（访问范围从小到大）：private（默认属性）、protected、public。</p></li><li><p>默认访问权限：struct（public）、class（private）</p></li><li><p>自身类对象不能作为类的成员。</p></li><li><p>类是相似特征的对象的抽象，对象是类的一个实例。</p></li></ul><p>对象：</p><ul><li><p>数据封装就是将一组数据和与这组数据有关操作组装在一起,形成一个实体,这个实体也就是<strong>对象</strong>。</p></li><li><p>面向对象编程（OOP）的三大特征分别是封装、继承和多态。它们各自的基本目的如下：</p><ol><li><p><strong>封装</strong>：基本目的是<strong>隐藏内部实现</strong>。</p></li><li><p><strong>继承</strong>：基本目的是<strong>实现代码的重用</strong>。</p></li><li><p><strong>多态</strong>：基本目的是<strong>改写对象行为</strong>。多态包括编译时多态（函数重载、运算符重载）和运行时多态（虚函数、抽象类），能够根据对象的实际类型来调用相应的方法，从而实现更加灵活的代码设计。</p></li></ol></li><li><p>面向对象的三大设计原则：1.封装变化点    2.优先使用组合而非继承    3.针对抽象进行编程</p></li></ul><p>过程：</p><ul><li>面向过程编程的基本单位是<strong>函数</strong>。</li></ul><p>指针：</p><ul><li><p>静态成员函数没有this指针。</p></li><li><p>指针本身并不会分配或释放内存空间。</p></li><li><p>this指针（是隐藏的）会保证每个对象拥有自己的数据成员，但共享处理这些数据的代码。</p></li></ul><p>一个函数功能不太复杂，但要求被<strong>频繁调用</strong>，则应把它定义为 <strong>内联函数</strong>。</p><p>公有的静态成员函数,可以通过<strong>对象</strong>或<strong>类名</strong>进行调用。</p><h2 id="第三章、运算符重载"><a href="#第三章、运算符重载" class="headerlink" title="第三章、运算符重载"></a>第三章、运算符重载</h2><p>运算符重载是对已有的运算符重新进行定义，使其能够在程序员定义的类型上进行操作。本质是函数重载。</p><p>流输出运算符（&lt;&lt;）需要重载为全局函数，因为其左操作数的类型只能是ostream类型。</p><p>输入输出运算符应该重载为类的友元函数。</p><p>运算符按照全局函数方式进行重载,，不必声明为友元函数。</p><p><strong>重载运算符</strong>由关键字<strong>operator</strong>和其后要重载的运算符共同组成。</p><p>单目运算符（<strong>单目运算符使用成员函数重载可以不用形参，双目运算符使用一个参数。</strong>）</p><ol><li><p><strong>递增和递减运算符</strong>：<code>++</code> 和 <code>--</code>，用于分别增加或减少操作数的值。</p></li><li><p><strong>取地址和间接引用运算符</strong>：<code>&amp;</code> 和 <code>*</code>，分别用于获取变量的地址和访问指针所指向的值。</p></li><li><p><strong>正负号运算符</strong>：<code>+</code> 和 <code>-</code>，用于表示数字的正负。</p></li><li><p><strong>逻辑非运算符</strong>：<code>!</code>，用于对布尔值进行取反操作。</p></li><li><p><strong>按位取反运算符</strong>：<code>~</code>，用于对二进制数进行按位取反操作。</p></li><li><p><strong>sizeof 运算符</strong>：<code>sizeof</code>，用于返回数据类型或变量所占内存的字节数。</p></li><li><p><strong>类型转换运算符</strong>：例如 <code>(int)</code>，用于执行显式类型转换。</p></li></ol><p><strong>在C++中，只能使用成员函数重载的运算符有：&#x3D;、()、[]、-&gt;</strong></p><h2 id="第四章、继承与派生"><a href="#第四章、继承与派生" class="headerlink" title="第四章、继承与派生"></a>第四章、继承与派生</h2><p>在派生类中基类的保护或者基类公有都可以直接访问，基类的私有成员只能由基类的成员函数来访问。</p><p>在公有继承的情况下，基类的公有或保护成员在派生类中的访问权限<strong>保持不变。</strong></p><p>C++语言建立类族是通过类的继承，继承包括单继承和多继承。</p><p>派生类和基类的关系（多对多）也称为 “is-a” 关系。这种关系用来描述一个对象是另一个对象的一种特殊类型。例如，”鱼是一种动物” 。</p><p>继承被称为“is-a”关系，组合被称为“has-a”关系。</p><p>两个类即有相同的功能，也有不同的功能，则应该让这两个类派生自同一个基类，相同的功能写在基类,中，不同的功能写在派生类中。</p><p> 在基类指针指向派生类对象时，基类指针代表<strong>抽象</strong>和<strong>稳定</strong>的，派生类对象代表<strong>具体</strong>和<strong>变化</strong>的。</p><p>无论采用什么样的继承方式，派生类包括基类的所有成员，包括私有成员，但不能直接访问私有成员。</p><p>公有继承对派生类继承成员的访问控制权限影响：</p><table><thead><tr><th>基类成员访问属性</th><th>public</th><th>protected</th><th>private</th><th>不可访问</th></tr></thead><tbody><tr><td><strong>在派生类中的访问属性</strong></td><td><strong>public</strong></td><td><strong>protected</strong></td><td><strong>不可访问</strong></td><td><strong>不可访问</strong></td></tr></tbody></table><p>保护继承对派生类继承成员的访问控制权限影响：</p><table><thead><tr><th>基类成员访问属性</th><th>public</th><th>protected</th><th>private</th><th>不可访问</th></tr></thead><tbody><tr><td><strong>在派生类中的访问属性</strong></td><td><strong>protected</strong></td><td><strong>protected</strong></td><td><strong>不可访问</strong></td><td><strong>不可访问</strong></td></tr></tbody></table><p>私有继承对派生类继承成员的访问控制权限影响：</p><table><thead><tr><th>基类成员访问属性</th><th>public</th><th>protected</th><th>private</th><th>不可访问</th></tr></thead><tbody><tr><td><strong>在派生类中的访问属性</strong></td><td><strong>private</strong></td><td><strong>private</strong></td><td><strong>不可访问</strong></td><td><strong>不可访问</strong></td></tr></tbody></table><ul><li><strong>重载</strong>：同一作用域中函数名相同但参数列表不同。</li><li><strong>隐藏</strong>：派生类中定义的同名函数隐藏了基类中的所有同名函数。</li><li><strong>覆盖</strong>：派生类中定义的虚函数与基类中同名且参数列表相同的虚函数，覆盖基类实现，实现运行时多态性。</li></ul><h2 id="第五章、多态与虚函数"><a href="#第五章、多态与虚函数" class="headerlink" title="第五章、多态与虚函数"></a>第五章、多态与虚函数</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态实现需要满足的条件：</p><ol><li><p>基类声明虚函数。</p></li><li><p>派生类重写基类的虚函数。</p></li><li><p>将基类指针指向派生类对象，通过基类指针访问虚函数。</p></li></ol><p>多态是一种不同的对象调用名称相同的函数，却因上下文不同会有不同实现的一种机制。</p><p>多态有两种形式，分别是重载实现的<strong>静态</strong>多态和虚函数实现的<strong>动态</strong>多态。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数是基类中声明的函数，使用关键字 <code>virtual</code> 标记。虚函数可以在派生类中被重写，从而实现不同的行为。</p><p>声明虚函数需要注意：</p><ol><li><p>构造函数不能声明为虚函数，析构函数可以。</p></li><li><p>虚函数不能是静态成员函数。</p></li><li><p>友元函数不能声明为虚函数，但虚函数可以作为另一个类的友元函数。</p></li></ol><p>在C++中，实现动态多态的核心数据结构是一张<strong>虚函数表</strong>（Vtable）。</p><p>基类和派生类中拥有原型相同的成员函数，且基类指针指向派生类对象，通过基类指针调用该函数时，如果该函数是<strong>虚函数</strong>，则函数的调用取决于<strong>对象</strong>的类型；如果该函数<strong>不是虚函数</strong>，则函数调用取决于<strong>变量</strong>的类型。</p><p><strong>纯虚函数</strong>是在基类中使用 <code>= 0</code> 声明的虚函数，没有函数体，必须在派生类中实现。拥有纯虚函数的类称为抽象类，无法直接创建该类的实例.</p><p>纯虚函数用于定义接口，确保所有派生类都实现这些函数，使基类成为抽象类，不能实例化。纯虚函数强制派生类提供具体实现，从而实现动态多态。</p><p>关键字override可以检测派生类对基类虚函数的重写是否正确。</p><p> C++的STL主要是通过<strong>模版编程</strong>实现的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理</title>
      <link href="/2024/06/22/zi-ran-yu-yan-chu-li/"/>
      <url>/2024/06/22/zi-ran-yu-yan-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="自然语言处理（25-A6309-16-00）"><a href="#自然语言处理（25-A6309-16-00）" class="headerlink" title="自然语言处理（25-A6309-16:00）"></a>自然语言处理（25-A6309-16:00）</h1><h2 id="第一章、绪论"><a href="#第一章、绪论" class="headerlink" title="第一章、绪论"></a>第一章、绪论</h2><p><strong>自然语言处理</strong>是利用计算机对自然语言的形、音、义等信息进行处理，即对字、词、句、篇章的输入、输出、识别、分析、理解、生成等进行操作和加工的过程。</p><p>NLP机制涉及的两个流程：自然语言理解、自然语言生成。</p><p>NLP的发展历程：萌芽期、发展期、繁荣期。</p><p>NLP研究内容包括机器翻译、信息检索、文本分类、智能问答、信息过滤、自动文摘、信息抽取、舆情分析、语音识别、自动校对。</p><p>NLP应用包括百度翻译、图灵机器人、微信语言转文字、新闻自动分类。</p><p>NLP流程：</p><ol><li><p>语料获取</p></li><li><p>语料预处理</p><ol><li><p>去除数据中非文本内容</p></li><li><p>中文分词（如jieba）</p></li><li><p>词性标注</p></li><li><p>去停用词</p></li></ol></li><li><p>文本向量化（常用模型有：词袋模型—-最简单的模型、独热表示、TF-IDF表示、n-gram模型、Word2Vec）</p></li><li><p>模型构建（机器学习：KNN、SVM、K-means 深度学习：RNN、CNN、Seq2Seq）</p></li><li><p>模型训练</p></li><li><p>模型评价</p></li></ol><h2 id="第二章、语料库"><a href="#第二章、语料库" class="headerlink" title="第二章、语料库"></a>第二章、语料库</h2><p>语料库以结构划分可分为<strong>平衡结构语料库</strong>与<strong>自然随机结构语料库</strong>。</p><p>构建语料库应考虑：代表性、结构性、平衡性、规模性</p><ul><li><p><strong>concordance</strong>：显示某个词在文本中的所有出现位置及其上下文。</p></li><li><p><strong>common_contexts</strong>：显示两个或多个词共同出现的上下文。</p></li><li><p><strong>sorted</strong>：用于对列表进行排序，不是专门用于NLP的函数。</p></li><li><p><strong>collocations</strong>：用于搜索搭配词语的函数</p></li><li><p><strong>categories</strong>：返回语料库中分类标签的列表</p></li><li><p><strong>raw</strong>：返回语料库中原始的未处理文本。</p></li><li><p>open(fileid)：打开指定ID的文件，但不用于获取文件ID列表。</p></li><li><p><strong>fileids</strong>：用于获取语料库中的文件</p></li><li><p><strong>read</strong>：读取作品集文本</p></li><li><p><strong>count</strong>：查询词频</p></li><li><p>FreqDist：查询文本中词汇频数分布</p></li><li><p>dispersion_plot：绘制指定词分布情况离散图</p></li></ul><h2 id="第三章、正则表达式"><a href="#第三章、正则表达式" class="headerlink" title="第三章、正则表达式"></a>第三章、正则表达式</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>import re</p><p>匹配文本</p><ul><li><p>match：需要字符串开头匹配，格式为re.match(pattern,string,flags)。</p></li><li><p>search： 不需要字符串开头匹配，格式为re.search(pattern,string,flags)。</p></li><li><p>findall：会返回所有匹配结果的列表，search只返回第一个，格式为re.findall(pattern,string,flags)。</p></li></ul><p>替换</p><ul><li>sub：将所有匹配到的字符串替换为指定字符串，格式为re.sub(pattern,repl,string)。</li></ul><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除”\n”外任意字符</td></tr><tr><td>[ ]</td><td>匹配括号内任意字符</td></tr><tr><td>|</td><td>匹配A或B</td></tr><tr><td>^</td><td>匹配^开头的内容</td></tr><tr><td>$</td><td>匹配$结尾内容</td></tr><tr><td>?</td><td>前面的元素可选，并且最多匹配1次</td></tr><tr><td>*</td><td>前面的元素会被匹配0次或多次</td></tr><tr><td>+</td><td>前面的元素会被匹配1次或多次</td></tr><tr><td>{n}</td><td>前面的元素会被匹配n次</td></tr><tr><td>{n,}</td><td>前面的元素至少会被匹配n次</td></tr><tr><td>{n,m}</td><td>前面的元素至少匹配n次，至多匹配m次</td></tr></tbody></table><table><thead><tr><th>预定义字符</th><th>说明</th></tr></thead><tbody><tr><td>\w</td><td>字、字母、数字</td></tr><tr><td>\W</td><td>非（字、字母、数字）</td></tr><tr><td>\s</td><td>空白字符</td></tr><tr><td>\S</td><td>非空白字符</td></tr><tr><td>\d</td><td>数字</td></tr><tr><td>\D</td><td>非数字</td></tr><tr><td>\b</td><td>单词的边界</td></tr><tr><td>\B</td><td>非单词的边界</td></tr></tbody></table><p>使用转义字符“\”可以将特殊字符转义为普通字符。</p><h2 id="第四章、中文分词技术"><a href="#第四章、中文分词技术" class="headerlink" title="第四章、中文分词技术"></a>第四章、中文分词技术</h2><h3 id="基于规则分词"><a href="#基于规则分词" class="headerlink" title="基于规则分词"></a>基于规则分词</h3><p><strong>正向最大匹配法</strong>（切分文本后删除最后一个字符再与词典匹配，失败则重复操作）</p><p><strong>逆向最大匹配法</strong>（与正向最大匹配法原理相反）</p><p><strong>双向最大匹配法</strong>（将正向最大匹配法与逆向最大匹配法的结果对比，选取切分次数较少的结果）</p><h3 id="基于统计分词"><a href="#基于统计分词" class="headerlink" title="基于统计分词"></a>基于统计分词</h3><p>基于规则的中文分词会遇到<strong>歧义问题</strong>（包括交集型切分歧义和组合型切分歧义）和<strong>未登录词问题</strong>（包括普通新词汇和专有名词）。</p><h3 id="n-gram模型（见p52）"><a href="#n-gram模型（见p52）" class="headerlink" title="n-gram模型（见p52）"></a>n-gram模型（见p52）</h3><h3 id="数据平滑"><a href="#数据平滑" class="headerlink" title="数据平滑"></a>数据平滑</h3><p>数据平滑可以应对数据稀疏即出现式子中分子或分母为零的情况。</p><ol><li><p>加1平滑（规定任何词语在语料库中都至少出现一次，即使没有出现过）</p></li><li><p>古德-图灵估计法（将所有看得见的事件概率适当调小分配给没有看见的事件）</p></li><li><p><strong>线性插值平滑</strong>（适合高价的n-gram模型，利用低价的n-gram模型对高价的n-gram进行线性插值，如没有“你好你”用“你好”替代）</p></li></ol><h3 id="维特比算法（见p60）"><a href="#维特比算法（见p60）" class="headerlink" title="维特比算法（见p60）"></a>维特比算法（见p60）</h3><h2 id="第五章、词性标注与命名实体识别"><a href="#第五章、词性标注与命名实体识别" class="headerlink" title="第五章、词性标注与命名实体识别"></a>第五章、词性标注与命名实体识别</h2><h3 id="词性标注规范"><a href="#词性标注规范" class="headerlink" title="词性标注规范"></a>词性标注规范</h3><p>现代汉语中的词性可分为实词和虚词，共12种。</p><p>jieba词性标注流程：</p><ol><li><p>加载离线统计词典</p></li><li><p>构建前缀词典</p></li><li><p>构建有向无环图</p></li><li><p>计算最大概率路径</p></li></ol><h3 id="命名实体识别"><a href="#命名实体识别" class="headerlink" title="命名实体识别"></a>命名实体识别</h3><p>中文实体识别面临的挑战：</p><ol><li><p>中文词灵活多变</p></li><li><p>中文词的嵌套情况复杂</p></li><li><p>中文词存在简化表达现象</p></li></ol><h3 id="CRF模型"><a href="#CRF模型" class="headerlink" title="CRF模型"></a>CRF模型</h3><p>CRF是基于统计方法的模型，主要来源于最大熵模型，可以被认为是一个无向图或一个马尔科夫随机场。</p><h3 id="中文命名实体识别"><a href="#中文命名实体识别" class="headerlink" title="中文命名实体识别"></a>中文命名实体识别</h3><p>在多分类问题中，最经典的模型是多项逻辑斯谛回归，也称为 Softmax 回归</p><p>特征函数（可以用于指示某个特定特征是否在当前样本中出现）输入值中，0表示特征不存在或条件不满足，1表示特征存在或条件满足。</p><h2 id="第六章、关键词提取"><a href="#第六章、关键词提取" class="headerlink" title="第六章、关键词提取"></a>第六章、关键词提取</h2><h3 id="关键词提取算法"><a href="#关键词提取算法" class="headerlink" title="关键词提取算法"></a>关键词提取算法</h3><p>关键词提取算法的性质：</p><ol><li><p>可读性</p></li><li><p>高速性</p></li><li><p>学习性</p></li><li><p>健壮性</p></li></ol><p>常见的关键词提取算法有TF-IDF算法、TextRank算法和主题模型算法（LSA和LDA算法）</p><h4 id="TF-IDF算法"><a href="#TF-IDF算法" class="headerlink" title="TF-IDF算法"></a>TF-IDF算法</h4><p>TF-IDF算法（词频-逆文档频率算法）主要思想是字词的重要性随着它在文档中出现次数的增加而上升，并随着它在语料库中出现频率的升高而下降。它 对文本内容的利用程度较低。</p><p>词频（TF）是一个词在一篇文档中出现频次的统计量。</p><p>逆文档（IDF）是一个词出现在文档集中文档的频次的统计量。一个词在文档集中越少的文档中出现，说明这个词对文档的区分能力越强。</p><h4 id="TextRank算法"><a href="#TextRank算法" class="headerlink" title="TextRank算法"></a>TextRank算法</h4><p>TextRank算法是一种基于图的文本排序算法，它可以用于自动摘要和提取关键词。与TF-IDF算法相比不依靠现有文档集提取关键词，只利用局部词汇之间的关系对后续关键词排序，随后从文本中提取词或句子，从而实现提取关键词和自动摘要。TextRank算法的基本思想来自PageRank算法。</p><h4 id="LSA和LDA算法"><a href="#LSA和LDA算法" class="headerlink" title="LSA和LDA算法"></a>LSA和LDA算法</h4><p>TF-IDF算法和TextRank算法无法在某些场合提取文本中的语义信息。</p><p>主题模型算法是在大量文档中发现潜在主题的一种统计模型，它能够识别文章中的隐藏主题，并揭示这些主题中包含的关键词。</p><p>LSA算法核心思想是将所拥有的词语-文档矩阵分解成相互独立的词语-主题矩阵和主题-文档矩阵。</p><p>LDA算法包含词语、主题和文档3层结构，它假定词语之间没有顺序，所有的词语都无序地放在一个袋子里，并且认为一个文档可以有多个主题对应不同的词语。</p><h2 id="第七章、文本向量化（主要有离散表示和分布式表示）"><a href="#第七章、文本向量化（主要有离散表示和分布式表示）" class="headerlink" title="第七章、文本向量化（主要有离散表示和分布式表示）"></a>第七章、文本向量化（主要有离散表示和分布式表示）</h2><h3 id="文本离散表示"><a href="#文本离散表示" class="headerlink" title="文本离散表示"></a>文本离散表示</h3><p>离散表示是一种基于规则和统计的向量化方法，常用的有词集模型和词袋(BOW)模型。特点是忽略文本信息中的语序信息和语境信息仅将其反映为若干维度的独立概念。词集模型采用独热表示，只要单词在字典中就置为1不管出现多少次；BOW模型只要文本中的词出现在字典就加1次出现多少加多少。</p><p>独热表示用一个长的向量表示一个词，向量长度为字典的大小，每个向量只有一个维度的值为1，其余维度的数值全部为0，为1的维度表示该词语在字典中的位置。</p><p>独热表示词向量的缺点：</p><ol><li><p>维数过高</p></li><li><p>矩阵稀疏</p></li><li><p>不能保留语义</p></li></ol><p>BOW模型用一个向量表示一句话或一个文档。</p><p>BOW模型的缺点：</p><ol><li><p>不能保留语义</p></li><li><p>维数高和稀疏性</p></li></ol><p>TF-IDF表示是用一个向量表示一句话或一个文档，它是在BOW模型基础上对词出现的频次赋予TF-IDF权值，对BOW模型进行修正，进而表示该词在文档集合中的重要程度。</p><h3 id="文本分布式表示"><a href="#文本分布式表示" class="headerlink" title="文本分布式表示"></a>文本分布式表示</h3><p>文本分布式表示是将每个词根据上下文从高维空间映射到一个低维度、稠密的向量上。常用模型有LSA矩阵分解模型、PLSA潜在语义分析概率模型、LDA文档生成模型和Word2Vec模型。</p><p>Word2Vec模型是简单化的神经网络模型。可以在巨量的字典和数据集中高效训练，其训练结果可以很好<strong>度量词与词之间的相似性</strong>。它的特点是当模型训练好后，并不会使用训练好的模型处理新的任务，<strong>真正需要的是模型通过训练数据所得的参数</strong>，如隐藏层的权重矩阵。</p><p>Word2Vec模型可以分为连词袋(CBOW)模型和跳字(Skip-Gram)模型。</p><p>Doc2Vec模型在Word2Vec模型输入层增添了一个与词向量同维度的段落向量（可看作另一个词向量）。</p><p>Doc2Vec模型存在分布式记忆(DM)模型和分布式词袋(DBOW)模型，分别对应Word2Vec模型里面的CBOW模型和Skip-Gram模型。</p><p>DM模型与CBOW模型相对应，可以根据上下文词向量和段落向量预测目标词的概率分布。</p><p>DBOW模型与Skip-Gram模型相对应，只输入段落向量，DBOW模型可以预测从段落中随机抽取的词组的概率分布。</p><table><thead><tr><th>CBOW模型</th><th>DM模型</th><th>Skip-Gram模型</th><th>DBOW模型</th></tr></thead><tbody><tr><td>输入特定词的上下文对应的独热向量</td><td>输入上下文词向量和段落向量</td><td>输入特定词的独热词向量</td><td>输入段落向量</td></tr><tr><td>输出这个特定词的概率分布</td><td>预测目标词概率分布</td><td>输出这个特定词的上下文概率分布</td><td>预测段落中随机抽取词组概率分布</td></tr><tr><td>适用于小型语料</td><td></td><td>在大型语料表现更好</td><td></td></tr></tbody></table><h2 id="第十章、NLP中的深度学习技术"><a href="#第十章、NLP中的深度学习技术" class="headerlink" title="第十章、NLP中的深度学习技术"></a>第十章、NLP中的深度学习技术</h2><p>循环神经网络(RNN)是以序列数据为输入，在序列的演进方向进行递归，并且所有节点按链式连接的递归神经网络。</p><p>RNN适合用于处理视频、语言、文本等与时序相关的问题。常见应用邻域有文本生成、语言模型、图像处理、机器翻译、语言识别、图像描述生成、文本相似度计算、音乐推荐和商品推荐等。</p><p>RNN结构按输入和输出的序列长度可划分为多对一、<strong>等长的多对多</strong>(经典结构)和非等长3种结构。  </p><p>双向RNN不仅考虑预测词前面的词，还<strong>考虑该词后面的内容</strong>。</p><p>LSTM使RNN具备避免梯度消失的特性，从而让RNN自身具备处理长期序列依赖的能力。LSTM神经网络模型使用门结构实现了对序列数据中的遗忘与记忆。</p><p>TensorFlow的特点：</p><ol><li><p>高度的灵活性</p></li><li><p>可移植性</p></li><li><p>综合了科研和产品</p></li><li><p>自动计算梯度导数</p></li><li><p>性能最优化</p></li><li><p>多语言支持</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 编写自动发送每日电子邮件报告的脚本</title>
      <link href="/2024/06/04/bian-xie-zi-dong-fa-song-mei-ri-dian-zi-you-jian-bao-gao-de-jiao-ben/"/>
      <url>/2024/06/04/bian-xie-zi-dong-fa-song-mei-ri-dian-zi-you-jian-bao-gao-de-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-编写自动发送每日电子邮件报告的脚本"><a href="#Python-编写自动发送每日电子邮件报告的脚本" class="headerlink" title="Python 编写自动发送每日电子邮件报告的脚本"></a>Python 编写自动发送每日电子邮件报告的脚本</h1><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a><strong>准备工作：</strong></h2><ul><li>安装必要的 Python 库，如 <code>smtplib</code>（用于发送邮件）和 <code>email</code>（用于构建电子邮件内容）。</li><li>准备邮件服务器的登录凭据和收件人的电子邮件地址。</li><li>Gmail: SMTP服务器地址是‘smtp.gmail.com’，端口 <code>587</code>。</li><li>Outlook: SMTP服务器地址是‘smtp.office365.com’，端口 <code>587</code>。</li></ul><h2 id="编写发送邮件的脚本："><a href="#编写发送邮件的脚本：" class="headerlink" title="编写发送邮件的脚本："></a><strong>编写发送邮件的脚本：</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_email_report</span>():</span><br><span class="line">    <span class="comment"># 电子邮件服务器和登录信息</span></span><br><span class="line">    smtp_server = <span class="string">&#x27;smtp.office365.com&#x27;</span></span><br><span class="line">    smtp_port = <span class="number">587</span></span><br><span class="line">    sender_email = ‘youremail@outlook.com’</span><br><span class="line">    sender_password = <span class="string">&#x27;yourpassword&#x27;</span></span><br><span class="line">    receiver_email = <span class="string">&#x27;receiver_email@example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建电子邮件消息</span></span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = sender_email</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = receiver_email</span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">f&#x27;Daily Report <span class="subst">&#123;datetime.date.today().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)&#125;</span>&#x27;</span></span><br><span class="line">    body = <span class="string">&#x27;This is the daily report email.&#x27;</span></span><br><span class="line">    msg.attach(MIMEText(body, <span class="string">&#x27;plain&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    server = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 连接到邮件服务器并发送邮件</span></span><br><span class="line">        server = smtplib.SMTP(smtp_server, smtp_port, timeout=<span class="number">60</span>)</span><br><span class="line">        server.set_debuglevel(<span class="number">1</span>)  <span class="comment"># 打开调试输出</span></span><br><span class="line">        server.starttls()</span><br><span class="line">        server.login(sender_email, sender_password)</span><br><span class="line">        text = msg.as_string()</span><br><span class="line">        server.sendmail(sender_email, receiver_email, text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Email sent successfully.&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Failed to send email: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> server:</span><br><span class="line">            server.quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    send_email_report()</span><br></pre></td></tr></table></figure><h2 id="设置定时任务："><a href="#设置定时任务：" class="headerlink" title="设置定时任务："></a><strong>设置定时任务：</strong></h2><h3 id="在-Windows-上使用任务计划程序"><a href="#在-Windows-上使用任务计划程序" class="headerlink" title="在 Windows 上使用任务计划程序"></a>在 Windows 上使用任务计划程序</h3><ol><li><p><strong>打开任务计划程序：</strong></p><ul><li>按 <code>Win + R</code> 打开“运行”对话框，输入 <code>taskschd.msc</code>，然后按 <code>Enter</code>。这将打开任务计划程序。</li></ul></li><li><p><strong>创建基本任务：</strong></p><ul><li>在任务计划程序窗口中，点击右侧的“创建基本任务”。</li></ul></li><li><p><strong>输入任务名称和描述：</strong></p><ul><li>在“名称”字段中输入任务名称，例如“Daily Email Report”。</li><li>在“描述”字段中输入任务描述（可选）。</li><li>点击“下一步”。</li></ul></li><li><p><strong>设置任务触发器：</strong></p><ul><li>选择“每日”，然后点击“下一步”。</li><li>设置任务开始时间，例如每天早上 9 点。点击“下一步”。</li></ul></li><li><p><strong>设置任务操作：</strong></p><ul><li>选择“启动程序”，然后点击“下一步”。</li><li>在“程序&#x2F;脚本”字段中，浏览选择 Python 可执行文件（例如 <code>python.exe</code>，通常位于 Python 安装目录中）。</li><li>在“添加参数”字段中输入 Python 脚本的完整路径，例如 <code>C:\path\to\your_script.py</code>。</li><li>在“起始于”字段中，可以输入脚本所在目录的路径（可选）。</li></ul></li><li><p><strong>完成任务创建：</strong></p><ul><li>检查所有设置是否正确，然后点击“完成”。</li></ul></li></ol><h3 id="在-macOS-或-Linux-上："><a href="#在-macOS-或-Linux-上：" class="headerlink" title="在 macOS 或 Linux 上："></a>在 macOS 或 Linux 上：</h3><p>使用 <code>cron</code> 定时任务工具。</p><ol><li><p>打开终端，输入 <code>crontab -e</code> 来编辑 cron 表。</p></li><li><p>添加以下行（假设脚本路径为 <code>/path/to/your_script.py</code>，并且 Python 可执行文件路径为 <code>/usr/bin/python3</code>）：   </p></li><li><p>启动脚本<br>  这表示每天早上 9 点运行脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 9 * * * /usr/bin/python3 /path/to/your_script.py</span><br></pre></td></tr></table></figure></li><li><p><em>测试脚本和任务：</em></p></li></ol><ul><li>手动运行脚本以确保其工作正常。</li><li>确认定时任务能够按预期运行，并检查邮件是否按时发送。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picture</title>
      <link href="/2024/05/11/picture/"/>
      <url>/2024/05/11/picture/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic.netbian.com/uploads/allimg/231225/231149-1703517109293c.jpg" class="lazyload placeholder" data-srcset="https://pic.netbian.com/uploads/allimg/231225/231149-1703517109293c.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" title="泡泡糖"></p><p><img src="https://pic.netbian.com/uploads/allimg/220628/234031-1656430831f0e2.jpg" class="lazyload placeholder" data-srcset="https://pic.netbian.com/uploads/allimg/220628/234031-1656430831f0e2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://pic.netbian.com/uploads/allimg/220606/224845-1654526925609d.jpg" class="lazyload placeholder" data-srcset="https://pic.netbian.com/uploads/allimg/220606/224845-1654526925609d.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://www.4kbizhi.com/d/file/2024/05/03/small091301Ig34e1714698781.jpg" class="lazyload placeholder" data-srcset="https://www.4kbizhi.com/d/file/2024/05/03/small091301Ig34e1714698781.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://www.4kbizhi.com/d/file/2024/04/22/small1503541Yr7h1713769434.jpg" class="lazyload placeholder" data-srcset="https://www.4kbizhi.com/d/file/2024/04/22/small1503541Yr7h1713769434.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://pic.netbian.com/uploads/allimg/240403/001025-17120742257800.jpg" class="lazyload placeholder" data-srcset="https://pic.netbian.com/uploads/allimg/240403/001025-17120742257800.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.6315501c36ce8af2245885606381e596?rik=BoLTa6LGOdHb0A&riu=http://pic.bizhi360.com/bbpic/57/6757.jpg&ehk=axqUeQIdIaWJbHOKP3KG8pkAuZXXGa5XfwG+gzQfPCk=&risl=&pid=ImgRaw&r=0" class="lazyload placeholder" data-srcset="https://ts1.cn.mm.bing.net/th/id/R-C.6315501c36ce8af2245885606381e596?rik=BoLTa6LGOdHb0A&riu=http://pic.bizhi360.com/bbpic/57/6757.jpg&ehk=axqUeQIdIaWJbHOKP3KG8pkAuZXXGa5XfwG+gzQfPCk=&risl=&pid=ImgRaw&r=0" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 壁纸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建+Github+Bamboo主题</title>
      <link href="/2024/05/10/hexo-bo-ke-da-jian-github-bamboo-zhu-ti/"/>
      <url>/2024/05/10/hexo-bo-ke-da-jian-github-bamboo-zhu-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客搭建-Github-Bamboo主题"><a href="#Hexo博客搭建-Github-Bamboo主题" class="headerlink" title="Hexo博客搭建+Github+Bamboo主题"></a>Hexo博客搭建+Github+Bamboo主题</h1><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><h4 id="node安装地址："><a href="#node安装地址：" class="headerlink" title="node安装地址："></a>node安装地址：</h4><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="Git安装包下载地址为："><a href="#Git安装包下载地址为：" class="headerlink" title="Git安装包下载地址为："></a>Git安装包下载地址为：</h4><p><a href="https://git-scm.com/">https://git-scm.com/</a></p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="验证-Hexo-安装是否成功"><a href="#验证-Hexo-安装是否成功" class="headerlink" title="验证 Hexo 安装是否成功"></a>验证 Hexo 安装是否成功</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="创建Hexo"><a href="#创建Hexo" class="headerlink" title="创建Hexo"></a>创建Hexo</h2><h3 id="命令行创建hexo目录"><a href="#命令行创建hexo目录" class="headerlink" title="命令行创建hexo目录"></a>命令行创建hexo目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;name&gt;  # 可加名字再创建一个目录储存hexo，不加就是在本文件夹</span><br></pre></td></tr></table></figure><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="Bamboo"><a href="#Bamboo" class="headerlink" title="Bamboo"></a>Bamboo</h2><h3 id="bamboo下载"><a href="#bamboo下载" class="headerlink" title="bamboo下载"></a>bamboo下载</h3><h4 id="GitHub安载"><a href="#GitHub安载" class="headerlink" title="GitHub安载"></a>GitHub安载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yuang01/hexo-theme-bamboo.git</span><br></pre></td></tr></table></figure><h4 id="gitee安装"><a href="#gitee安装" class="headerlink" title="gitee安装"></a>gitee安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/yuang01/hexo-theme-bamboo.git</span><br></pre></td></tr></table></figure><p>修改hexo根目录下的站点配置文件<code>_config.yml</code>，把主题改为<code>hexo-theme-bamboo</code>，通过主题文件夹下的<code>config.yml</code>配置主题即可</p><h4 id="或者npm来安装，进入hexo根目录使用如下命令"><a href="#或者npm来安装，进入hexo根目录使用如下命令" class="headerlink" title="或者npm来安装，进入hexo根目录使用如下命令"></a>或者npm来安装，进入hexo根目录使用如下命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-bamboo</span><br></pre></td></tr></table></figure><p>注意：此方法只支持Hexo在5.0.0版本以上 <strong>通过 npm 安装并不会在 themes 里生成主题文件夹，而是在 node_modules 里生成</strong> 修改hexo根目录下的站点配置文件<code>_config.yml</code>，把主题改为<code>bamboo</code></p><p>接着在hexo根目录下新建文件<code>_config.bamboo.yml</code>,从<code>node_modules</code>文件夹下找到<code>hexo-theme-bamboo</code>文件夹下的<code>_config.yml</code>，将里面的内容复制到<code>_config.bamboo.yml</code>文件中即可，在<code>_config.bamboo.yml</code>文件中对主题进行配置</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="config-yml文件中修改下面信息绑定自己的网址"><a href="#config-yml文件中修改下面信息绑定自己的网址" class="headerlink" title="_config.yml文件中修改下面信息绑定自己的网址"></a>_config.yml文件中修改下面信息绑定自己的网址</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h4 id="在bamboo下载生成的-config-yml（-config-bamboo-yml）可以更改页面配置"><a href="#在bamboo下载生成的-config-yml（-config-bamboo-yml）可以更改页面配置" class="headerlink" title="在bamboo下载生成的_config.yml（_config.bamboo.yml）可以更改页面配置"></a>在bamboo下载生成的_config.yml（_config.bamboo.yml）可以更改页面配置</h4><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><h4 id="点击头像旁边的加号再点击New-repository"><a href="#点击头像旁边的加号再点击New-repository" class="headerlink" title="点击头像旁边的加号再点击New repository"></a>点击头像旁边的加号再点击New repository</h4><h4 id="输入自己的项目名字，后面一定要加-http-github-io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫-A，那么仓库名字一定要是-http-A-github-io。"><a href="#输入自己的项目名字，后面一定要加-http-github-io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫-A，那么仓库名字一定要是-http-A-github-io。" class="headerlink" title="输入自己的项目名字，后面一定要加.http://github.io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫 A，那么仓库名字一定要是 http://A.github.io。"></a>输入自己的项目名字，后面一定要加.<a href="http://github.io后缀,readme初始化也要勾上.名称一定要和你的github名字完全一样,比如你github名字叫/">http://github.io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫</a> A，那么仓库名字一定要是 <a href="http://a.github.io./">http://A.github.io。</a></h4><h3 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Name&quot;</span><br><span class="line">git config --global user.email &quot;Email&quot;</span><br></pre></td></tr></table></figure><h5 id="Name和Email是我们注册Github时的用户名和邮箱。"><a href="#Name和Email是我们注册Github时的用户名和邮箱。" class="headerlink" title="Name和Email是我们注册Github时的用户名和邮箱。"></a>Name和Email是我们注册Github时的用户名和邮箱。</h5><h4 id="然后生成密钥："><a href="#然后生成密钥：" class="headerlink" title="然后生成密钥："></a>然后生成密钥：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Email&quot;</span><br></pre></td></tr></table></figure><h5 id="后面可以直接确定不用密码"><a href="#后面可以直接确定不用密码" class="headerlink" title="后面可以直接确定不用密码"></a>后面可以直接确定不用密码</h5><h4 id="密钥生成，一般存放在（-c-Users-you-ssh-id-rsa-pub-）需要复制，密钥后面有用"><a href="#密钥生成，一般存放在（-c-Users-you-ssh-id-rsa-pub-）需要复制，密钥后面有用" class="headerlink" title="密钥生成，一般存放在（&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.）需要复制，密钥后面有用"></a>密钥生成，一般存放在（&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.）需要复制，密钥后面有用</h4><h4 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h4><h5 id="在Github头像下面点击Settings，再点击SSH-and-GPG-keys，新建一个SSH，名字任意。"><a href="#在Github头像下面点击Settings，再点击SSH-and-GPG-keys，新建一个SSH，名字任意。" class="headerlink" title="在Github头像下面点击Settings，再点击SSH and GPG keys，新建一个SSH，名字任意。"></a>在Github头像下面点击Settings，再点击SSH and GPG keys，新建一个SSH，名字任意。</h5><h5 id="将上面的密钥复制到key"><a href="#将上面的密钥复制到key" class="headerlink" title="将上面的密钥复制到key"></a>将上面的密钥复制到key</h5><h4 id="本地连接Github"><a href="#本地连接Github" class="headerlink" title="本地连接Github"></a>本地连接Github</h4><h5 id="命令行输入（不要修改），出现用户名就是成功"><a href="#命令行输入（不要修改），出现用户名就是成功" class="headerlink" title="命令行输入（不要修改），出现用户名就是成功"></a>命令行输入（不要修改），出现用户名就是成功</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="搭建个人博客安装一键部署插件"><a href="#搭建个人博客安装一键部署插件" class="headerlink" title="搭建个人博客安装一键部署插件"></a>搭建个人博客安装一键部署插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><h3 id="新建文章-放在（-source-posts）可修改"><a href="#新建文章-放在（-source-posts）可修改" class="headerlink" title="新建文章 放在（.&#x2F;source&#x2F;_posts）可修改"></a>新建文章 放在（.&#x2F;source&#x2F;_posts）可修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;title&quot;</span><br></pre></td></tr></table></figure><h3 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h3><h4 id="删除（-source-posts）里面的md文件"><a href="#删除（-source-posts）里面的md文件" class="headerlink" title="删除（.&#x2F;source&#x2F;_posts）里面的md文件"></a>删除（.&#x2F;source&#x2F;_posts）里面的md文件</h4><h4 id="删除（-deploy-git）-这是上传GitHub生成的文件"><a href="#删除（-deploy-git）-这是上传GitHub生成的文件" class="headerlink" title="删除（.deploy_git）-这是上传GitHub生成的文件"></a>删除（.deploy_git）-这是上传GitHub生成的文件</h4><h4 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myaql常用命令</title>
      <link href="/2024/05/10/myaql-chang-yong-ming-ling/"/>
      <url>/2024/05/10/myaql-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="myaql常用命令"><a href="#myaql常用命令" class="headerlink" title="myaql常用命令"></a>myaql常用命令</h1><h2 id="mysql服务的启动和停止"><a href="#mysql服务的启动和停止" class="headerlink" title="mysql服务的启动和停止"></a>mysql服务的启动和停止</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql net <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure><h2 id="登陆mysql"><a href="#登陆mysql" class="headerlink" title="登陆mysql"></a>登陆mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="增加新用户"><a href="#增加新用户" class="headerlink" title="增加新用户"></a>增加新用户</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.<span class="operator">*</span> <span class="keyword">to</span> 用户名@登录主机 identified <span class="keyword">by</span> &quot;密码</span><br></pre></td></tr></table></figure><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure><h2 id="显示数据库列表"><a href="#显示数据库列表" class="headerlink" title="显示数据库列表"></a>显示数据库列表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><h2 id="显示数据表的结构"><a href="#显示数据表的结构" class="headerlink" title="显示数据表的结构"></a>显示数据表的结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="建库与删库"><a href="#建库与删库" class="headerlink" title="建库与删库"></a>建库与删库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 库名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 库名;</span><br></pre></td></tr></table></figure><h2 id="建表与删表"><a href="#建表与删表" class="headerlink" title="建表与删表"></a>建表与删表</h2><h3 id="a-进入数据库"><a href="#a-进入数据库" class="headerlink" title="a.进入数据库"></a>a.进入数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 库名;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段列表);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node常用命令</title>
      <link href="/2024/05/10/node-chang-yong-ming-ling/"/>
      <url>/2024/05/10/node-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><h2 id="检查版本与是否存在"><a href="#检查版本与是否存在" class="headerlink" title="检查版本与是否存在"></a>检查版本与是否存在</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;./node/node_global&quot;</span><br><span class="line">npm config set cache &quot;./node/node_cache&quot;</span><br></pre></td></tr></table></figure><h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br><span class="line">npm i nodemon -g</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><h3 id="readFile-异步-readFileSync-同步"><a href="#readFile-异步-readFileSync-同步" class="headerlink" title="&#x2F;&#x2F; readFile()异步 readFileSync()同步"></a>&#x2F;&#x2F; readFile()异步 readFileSync()同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./1.txt&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;2.txt&#x27;</span>,<span class="string">&#x27;hi&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><h3 id="用于处理-URL-查询字符串的工具"><a href="#用于处理-URL-查询字符串的工具" class="headerlink" title="-用于处理 URL 查询字符串的工具"></a>-<em>用于处理 URL 查询字符串的工具</em></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let qs = require(&#x27;querystring&#x27;);</span><br><span class="line">let str = qs.escape(&#x27;你好&#x27;);</span><br><span class="line">console.log(str)     </span><br><span class="line">let data = qs.unescape(str);     </span><br><span class="line">console.log(data)</span><br></pre></td></tr></table></figure><h2 id="使用express框架"><a href="#使用express框架" class="headerlink" title="使用express框架"></a>使用express框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装express</span><br><span class="line">npm i express -g</span><br><span class="line">#全局安装express脚手架</span><br><span class="line">npm i express-generator -g</span><br><span class="line">npm i nodemon -g</span><br><span class="line"># 创建项目</span><br><span class="line">express 项目名</span><br><span class="line"># 安装第三方依赖</span><br><span class="line">npm i mongoose ejs express-session multer --save</span><br><span class="line"># 运行项目</span><br><span class="line">npm start</span><br><span class="line">#允许跨域</span><br><span class="line">npm install cors</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2024/05/10/hexo-chang-yong-ming-ling/"/>
      <url>/2024/05/10/hexo-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><h2 id="hexo的部署"><a href="#hexo的部署" class="headerlink" title="hexo的部署"></a>hexo的部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo c  # 清理</span><br><span class="line">hexo g  # 生成静态文件</span><br><span class="line">hexo s  # 运行到本地</span><br><span class="line">hexo d  # 部署</span><br></pre></td></tr></table></figure><h2 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
